priority case (1'b1)
  cond0: y = a;
  cond1: y = b;
  cond2: y = c;
  default: y = d;
endcase

What priority means

Case items are checked top to bottom

First true match wins

Priority is explicit

How it synthesizes

‚Üí Priority mux chain (like if / else if)

Conceptually:

if (cond0)      y = a;
else if (cond1) y = b;
else if (cond2) y = c;
else            y = d;

//------------------------------------------------------------------

case (sel)
  2'b00: y = a;
  2'b01: y = b;
  2'b10: y = c;
  default: y = d;
endcase

  1Ô∏è‚É£ Plain case ‚Äî Tool assumes NOTHING
What the tool fears

Two case items might be true (overlap)

Or none might be true

So the tool must guarantee correctness for all illegal cases.

Hardware inferred (safe version)

Internally, the tool builds something like:

d0 = (sel == 2'b00);
d1 = (sel == 2'b01);
d2 = (sel == 2'b10);
d3 = (sel == 2'b11);

y = (d0 & a) |
    (d1 & b) |
    (d2 & c) |
    (d3 & d);

Key characteristics

Parallel decoders

OR-combine all results

Works even if:

Multiple di = 1

Glitches

Unknowns

Cost

More gates

More capacitance

Slightly worse timing

2Ô∏è‚É£ unique case ‚Äî Tool is allowed to trust you
What unique promises

‚ÄúExactly ONE case item will match ‚Äî never zero, never multiple.‚Äù

This lets the tool remove safety logic.

Hardware inferred (optimized)

The tool can now build:

y = mux(sel,
        00 ‚Üí a,
        01 ‚Üí b,
        10 ‚Üí c,
        11 ‚Üí d);


or even:

y = a when sel[1:0]==00
y = b when sel[1:0]==01
...

What changed

No OR trees

No overlap protection

No masking logic

‚û° Cleaner mux
‚û° Shorter critical path

3Ô∏è‚É£ The Crucial Difference (One Sentence)

case must be correct even if multiple items match.
unique case is allowed to assume only one item ever matches.

That‚Äôs it. That‚Äôs the core idea.

4Ô∏è‚É£ Why This Matters in Real Silicon
Timing

case ‚Üí decode + AND + OR

unique case ‚Üí direct mux select

Power

Fewer toggling gates

Less switching activity

Area

Fewer gates

5Ô∏è‚É£ FSM Example (Where This Is Obvious)
FSM state decode
unique case (state)
  IDLE  : next = RUN;
  RUN   : next = WAIT;
  WAIT  : next = IDLE;
endcase


Why unique?

FSM can only be in one state

Tool removes safety logic

Faster next-state logic

If you used plain case, tool must assume:

‚ÄúWhat if state bits are corrupted?‚Äù

So it protects hardware.

6Ô∏è‚É£ What About Simulation vs Synthesis?
Keyword	Simulation Effect	Synthesis Effect
case	No warnings	Conservative logic
unique case	Warns on 0 or >1 match	Optimized logic
priority case	Warns if none match	Priority mux
7Ô∏è‚É£ Interview-Level Explanation (Memorize This)

‚Äúunique case lets the tool assume mutual exclusivity and generate a clean mux.
Plain case generates defensive logic because overlaps are possible.‚Äù

If you say that, you‚Äôre above average.

Final Mental Model üß†

Think of unique as:

‚ÄúTrust me, this is one-hot / exclusive.‚Äù

Think of plain case as:

‚ÄúI‚Äôm not sure, please be safe.‚Äù
//-----------------------------------------------------------
RTL
unique case (state)
  IDLE : y = 0;
  RUN  : y = 1;
  WAIT : y = 0;
endcase

1Ô∏è‚É£ Boolean simplification

Let‚Äôs rewrite it logically:

y = 1 when state == RUN
y = 0 otherwise


That‚Äôs it.

2Ô∏è‚É£ What hardware is actually needed?

Only one compare is needed:

y = (state == RUN)

3Ô∏è‚É£ Gate-level netlist (explicit)

For RUN = 2'b01:

state[1] ----|>o----\
                     AND ---- y
state[0] ----------/


Where:

state[1] inverted

state[0] non-inverted

Netlist form
n1 = ~state[1]
y  = n1 & state[0]


That‚Äôs literally it.

4Ô∏è‚É£ No mux, no OR tree ‚Äî WHY?

Because:

IDLE and WAIT both assign 0

unique case allows collapsing cases

Tool does logic minimization

So instead of:

if state == RUN ‚Üí 1
else ‚Üí 0


It reduces to a single comparator

5Ô∏è‚É£ Compare with plain case (important contrast)
Plain case equivalent hardware
m_idle = (state == IDLE)
m_run  = (state == RUN)
m_wait = (state == WAIT)

y = (m_run & 1'b1) |
    (m_idle & 1'b0) |
    (m_wait & 1'b0)


Which simplifies to:

y = m_run


BUT the decode logic still exists unless optimization removes it.
With unique, the tool is allowed to remove it confidently.

6Ô∏è‚É£ Critical interview insight üî•

If the RTL were:

unique case (state)
  IDLE : y = a;
  RUN  : y = b;
  WAIT : y = c;
endcase

Netlist becomes
y = mux(state)


Not decoder + OR.

That‚Äôs the key hardware difference.

7Ô∏è‚É£ One-line answer for interview

‚ÄúThis unique case synthesizes to a simple compare: y = (state == RUN), not a priority chain or decoder.‚Äù

If you want, next we can:

Compare timing paths (case vs unique case)

Show how illegal state affects silicon

Convert this to one-hot FSM version

Just say the word.



  
